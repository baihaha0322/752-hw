# -*- coding: utf-8 -*-
"""HW1 752.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EagaF6jy3nVrnrpZzXj46xofcCDvOT8h
"""

#!/usr/bin/python
__author__ = "Donglu Bai"
__email__ = "donglu.bai@yale.edu"
__copyright__ = "Copyright 2022"
__license__ = "GPL"
### Usage: python hw1.py -i <input file> -s <score file>
### Example: python hw1.py -i input.txt -s blosum62.txt
### Note: Smith-Waterman Algorithm

import argparse
import pandas as pd
import numpy as np

def runSW(inputFile, scoreFile, open_gap, extension):
    ### calculation
    ### write output
    score_file = pd.read_csv(scoreFile,delim_whitespace=True)     
    inputdata = pd.read_table(inputFile, header = None)
    seq1 = np.array(inputdata)[0][0]
    seq2 = np.array(inputdata)[1][0]
    # create an empty score matrix 
    score_matrix=np.zeros((len(seq1) + 1, len(seq2) + 1), np.int)
    
    # build score matrix 
    for j in range(1,len(seq1)+1):
        
        for i in range(1,len(seq2)+1):
          
            match_mismatch = score_matrix[j - 1, i - 1] + score_file.loc[seq1[j-1],seq2[i-1]] # diagnoal match score
            # deletion
            deletion_total=np.array([])
            max_gap_length=j            
            for m in range(1, max_gap_length+1):
              deletion_total=np.append(deletion_total, score_matrix[j-1-(m-1),i]+open_gap+extension*(m-1))
            deletion_score=score_matrix[j,i]+np.max(deletion_total)
            # insertion
            insertion_total=np.array([])
            max_gap_length=i
            for m in range(1, max_gap_length+1):
             insertion_total=np.append(insertion_total, score_matrix[j,i-1-(m-1)]+open_gap+(m-1)*extension)
            insertion_score=score_matrix[j,i]+np.max(insertion_total)
            maxvalue = max(match_mismatch,deletion_score,insertion_score,0)
            if maxvalue > 0:
                score_matrix[j,i] = maxvalue
    score_place = np.where(score_matrix==np.max(score_matrix)) # where the score_matrix has the max value
    return seq1,seq2,score_matrix,score_place
    # traceback
def traceback(matrix, max_place,seq_1,seq_2):
    END, DIAG, UP, LEFT = range(4)
    aligned_seq1 = []
    aligned_seq2 = []
    x, y         = max_place
    move         = next_move(matrix, x, y)
    m=0
    while move != END:
        if move == DIAG:
            aligned_seq1.append(seq_1[x[0] - 1])
            aligned_seq2.append(seq_2[y[0] - 1])
            x -= 1
            y -= 1
        elif move == UP:
            aligned_seq1.append(seq_1[x[0] - 1])
            aligned_seq2.append('-')
            x -= 1
            m +=1
        else:
            aligned_seq1.append('-')
            aligned_seq2.append(seq_2[y[0] - 1])
            y -= 1

        move = next_move(matrix, x, y)
    aligned_seq1.append(seq_1[x[0] - 1])
    aligned_seq2.append(seq_2[y[0] - 1])
    aligned_seq1=''.join(reversed(aligned_seq1))
    aligned_seq2=''.join(reversed(aligned_seq2))

    return aligned_seq1,aligned_seq2,m
def next_move(matrix,x,y):
    diag = matrix[x-1,y-1]
    up   = matrix[x-1,y]
    left = matrix[x,y-1]
    if diag >= up and diag >= left:     
        return 1 if diag != 0 else 0    # 1 means a diag move, 0 means stop 
    elif up > diag and up >= left:     
        return 2 if up != 0 else 0      # move up or end.
    elif left > diag and left > up:
        return 3 if left != 0 else 0    # move left or end.
    else:
     raise ValueError('not valid')
def print_matrix(seq_1,seq_2,matrix,alignedseq1,alignedseq2,num):
    print("----------------------\n|Sequences|\n----------------------")
    print('sequence1')
    print(seq_1)
    print('sequence2')
    print(seq_2)
    print("----------------------\n|Score Matrix|\n----------------------")
    show_score_matrix = pd.DataFrame(matrix)
    show_score_matrix.index    = np.append('',list(map(str, seq_1)))
    show_score_matrix.columns  = np.append('',list(map(str, seq_2)))
    show_score_matrix = show_score_matrix.T
    finalmax = np.max(matrix).astype("int64")
    print(show_score_matrix.to_csv(sep = '\t'),end='')
    print("----------------------\n|Best Local Alignment|\n----------------------")
    output1 = 'Alignment Score:' + str(finalmax)
    print(output1)
    print("Alignment Results:")
    alignment_string = []
    for base1, base2 in zip(alignedseq1, alignedseq2):
      if base1 == base2:
        alignment_string.append('|')
      else: 
        alignment_string.append(' ')
    print(' '*(seq_2.index(alignedseq2[0]))+'('+''.join(map(str,alignedseq1))+')')
    print(' '*((seq_2.index(alignedseq2[0]))+1)+''.join(alignment_string)+' ') 

    print(seq_2[0:seq_2.index(alignedseq2[0])]+'('+''.join(map(str,alignedseq2))+')'+seq_2[len(seq_2)-(len(seq_2)-(len(alignedseq2)-num+seq_2.index(alignedseq2[0]))):])

seq1,seq2,score_matrix,score_place =runSW("/content/input.txt", "/content/blosum62.txt", -2, -1)
aligned_seq1,aligned_seq2,m= traceback(score_matrix, score_place,seq1,seq2)
next_move(score_matrix,score_place[0],score_place[1])
print_matrix(seq1,seq2,score_matrix,aligned_seq1,aligned_seq2,m)